/* ArduGrid = Nanode + Power Meter using Analog ADE7755 IC + datastreaming to Pachube
=====================================================================================
V1.0
MercinatLabs / MERCINAT SARL France
By: Thierry Brunet de Courssou
http://www.mercinat.com
Created 11 Oct 2011
Last update: 29 Nov 2011
Project hosted at: http://code.google.com/p/ardugrid/ - Repository type: Subversion
Version Control System: TortoiseSVN 1.7.1, Subversion 1.7.1, for Window7 64-bit - http://tortoisesvn.net/downloads.html

Configuration
-------------
Hardware: Nanode v5 + Hoch Pulses Power Meter board using Analog ADE7755 IC
  -- http://hochgroup.en.alibaba.com/product/424588718-200841852/single_phase_electric_kilowatt_hour_ph_meter.html?tracelog=cgsotherproduct1
  -- http://www.analog.com/en/analog-to-digital-converters/energy-measurement/ade7755/products/product.html
  -- Hoch board has been modified to get high frequency CF and to get REVP power sign
  -- REVP is routed through an additional opto isolator

SW Arduino IDE RC2 for Windows at http://code.google.com/p/arduino/wiki/Arduino1
-- did not test with Arduino IDE 0022 or 0023

Project summary
---------------
Real-time streaming of energy production to grid & power sign (Production/Consumption)

Comments
--------
This code has been abundantly commented with lots of external links to serve as a tutorial for newbies

Hardware: Nanode + ADE7755 powermeter board with REVP routed through an additional opto coupler
 
Pulses generated by ADE7755 via opto-isolator and 18k pull-up resistor
- interrupt 1 is for digital pin 3 --> Power pulses
- digital pin 4 --> REVP sign of power  (sign detection is show on LED on pin 6)

// RAM space is very limited so use PROGMEM to conserve memory with strings
// However PROGMEM brings some instabilities, so not using it for now. 
// Will check from time to time if this is solved in future versions of 
// Arduino IDE and EtherCard library.

// As Pachube feeds may hang at times, we reboot regularly. 
// We will monitor stability then remove reboot when OK.

// The  datastream ID10 is a Nanode health indicator. This is simply incremeting a number so any
// interruption can be easily addentified as a discontinuity on the ramp graph shown on Pachube

// The last datastream ID11 is a Pachube health indicator. 
// The time between sending data to Pachube and receiving the acknowledge message
// is recorded. This will reveal if Pachube service is responding in a timely fashon. 

// Mercinat Etel test site Nanodes -- As we use one Nanode per sensor, making use of the MAC allows to assign IP by DHCP and identify each sensor
// -------------------------------
// Nanode: 1	Serial: 266	 Mac: 00:04:A3:2C:2B:D6 --> Grid Aurora
// Nanode: 2	Serial: 267	 Mac: 00:04:A3:2C:30:C2 --> Grid FemtoGrid
// Nanode: 3	Serial: 738	 Mac: 00:04:A3:2C:1D:EA --> Grid Skystream
// Nanode: 4	Serial: 739	 Mac: 00:04:A3:2C:1C:AC --> Grid RMS #1
// Nanode: 5	Serial: 740	 Mac: 00:04:A3:2C:10:8E --> Grid RMS #2
// Nanode: 6	Serial: 835	 Mac: 00:04:A3:2C:28:FA -->  6 m anemometer/vane
// Nanode: 7	Serial: 836	 Mac: 00:04:A3:2C:26:AF --> 18 m anemometer/vane
// Nanode: 8	Serial: 837	 Mac: 00:04:A3:2C:13:F4 --> 12 m anemometer/vane
// Nanode: 9	Serial: 838	 Mac: 00:04:A3:2C:2F:C4 -->  9 m anemometer/vane

// Pachube feeds assignement
// -------------------------
// The is one Pachube feed per sensor. This appears to be the most flexible scheme.
// Derived/computed feeds/datastreams may be uploaded later via the Pachube API
// Will post such applications on project repository 
//  38277  - Anemometer/Vane Etel  6 m -- https://pachube.com/feeds/38277
//  38278  - Anemometer/Vane Etel  9 m -- https://pachube.com/feeds/38278
//  38279  - Anemometer/Vane Etel 12 m -- https://pachube.com/feeds/38279
//  38281  - Anemometer/Vane Etel 18 m -- https://pachube.com/feeds/38281
//  35020  - Skystream    (ADE7755 via CF & REVP - modified Hoch Energy Meter board) -- https://pachube.com/feeds/35020
//  37668  - WT FemtoGrid (ADE7755 via CF & REVP - modified Hoch Energy Meter board) -- Private feed -- https://pachube.com/feeds/37668
//  37667  - WT Aurora on (ADE7755 via CF & REVP - modified Hoch Energy Meter board) -- Private feed -- https://pachube.com/feeds/37667
//  40385  - Grid RMS #1  (ADE7753 via SPI - Olimex Energy Shield) -- https://pachube.com/feeds/40385
//  40386  - Grid RMS #2  (ADE7753 via SPI - Olimex Energy Shield) -- https://pachube.com/feeds/40386
//  40388 -- Turbine A -- Private feed -- https://pachube.com/feeds/40388
//  40389 -- Turbine B -- Private feed -- https://pachube.com/feeds/40389
//  37267 -- newly built Nanode test feed (Mercinat) -- https://pachube.com/feeds/37267
//  40447 -- Free room for anyone to test the ArduWind code)   -- https://pachube.com/feeds/40447
//  40448 -- Free room for anyone to test the ArduGrid code)   -- https://pachube.com/feeds/40448
//  40449 -- Free room for anyone to test the ArduSky code)    -- https://pachube.com/feeds/40449
//  40450 -- Free room for anyone to test the SkyChube code)   -- https://pachube.com/feeds/40450
//  40451 -- Free room for anyone to test the NanodeKit code)  -- https://pachube.com/feeds/40451

========================================================================================================*/
 
// ==================================
// -- Ethernet/Pachube section
// ==================================

#include <EtherCard.h>  // get latest version from https://github.com/jcw/ethercard
  // EtherShield uses the enc28j60 IC (not the WIZnet W5100 which requires a different library)
  
#include <NanodeUNIO.h>   // get latest version from https://github.com/sde1000/NanodeUNIO 
  // All Nanodes have a Microchip 11AA02E48 serial EEPROM chip
  // soldered to the underneath of the board (it's the three-pin
  // surface-mount device).  This chip contains a unique ethernet address
  // ("MAC address") for the Nanode.
  // To read the MAC address the library NanodeUNIO is needed
  
// If the above library has not yet been updated for Arduino1 (Rev01, not the beta 0022), 
// in the 2 files NanodeUNIO.h and NanoUNIO.cpp
// you will have to make the following modification:
    //#if ARDUINO >= 100
    //  #include <Arduino.h> // Arduino 1.0
    //#else
    //  #include <WProgram.h> // Arduino 0022+
    //#endif

byte macaddr[6];  // Buffer used by NanodeUNIO library
NanodeUNIO unio(NANODE_MAC_DEVICE);
boolean bMac; // Success or Failure upon function return

#define APIKEY  "fqJn9Y0oPQu3rJb46l_Le5GYxJQ1SSLo1ByeEG-eccE"  // MercinatLabs FreeRoom Pachube key for anyone to test this code
                        
#define REQUEST_RATE 10000 // in milliseconds - Pachube update rate
unsigned long lastupdate;  // timer value when last Pachube update was done
uint32_t timer;  // a local timer

byte Ethernet::buffer[550];
Stash stash;     // For filling/controlling EtherCard send buffer using satndard "print" instructions

int MyNanode = 0;

// END -- Ethernet/Pachube section



// START -- Powermeter section
// ============================

unsigned long PulseTimeNow = 0; // Time stamp (in millisecons) for pulse triggering the interrupt
unsigned long PulseTimeLast = 0; // Time stamp of the previous pulse
unsigned long PulseTimeInterval = 0;; // Time interval since last pulse
unsigned long PulsesCumulatedTime = 0; // Time Interval since last power computation 
unsigned long PulsesNbr = 0;           // Number of pulses since last power computation 
unsigned long MinPulseTimeInterval = 1000000000;

float Frequency = 0;
float Power = 0;
boolean bPowerSign = 0;

// Misc.
// -----
int FirstLoop = 0;

// END -- PowerMeter section

int TRUE = 1;
int FALSE = 0;


// **********************
// -- SETUP
// **********************
void setup()
{
  pinMode(4, INPUT);
  pinMode(6, OUTPUT);
  for (int i=0; i < 10; i++) { digitalWrite(6,!digitalRead(6)); delay (50);} // blink LED 6 a bit to greet us after reboot
  
  bPowerSign = digitalRead(4);  // Read Power Sign REVP
  // show power sign on LED 6  (LED ON = Inverter Production)
  if (bPowerSign){ digitalWrite(6, 0);} else {digitalWrite(6, 1);}  // If Production, then LED 6 is illuminated. 
  
 Serial.begin(115200);
 Serial.println("\n\nArduGrid V1 - MercinatLabs (29 Nov 2011)");
  
  GetMac(); // get MAC adress from the Microchip 11AA02E48 located at the back of the Nanode board
  
  // Identify which sensor is assigned to this board
  // If you have boards with identical MAC last 2 values, you will have to adjust your code accordingly
  switch ( macaddr[5] )
  {
    case 0xFA: MyNanode = 6;  Serial.print("n6 "); Serial.print("f38277 - "); Serial.println("Etel 6 m") ; break; 
    case 0xC4: MyNanode = 9;  Serial.print("n9 "); Serial.print("f38278 - "); Serial.println("Etel 9 m") ; break;
    case 0xF4: MyNanode = 8;  Serial.print("n8 "); Serial.print("f38279 - "); Serial.println("Etel 12 m"); break;
    case 0xAF: MyNanode = 7;  Serial.print("n7 "); Serial.print("f38281 - "); Serial.println("Etel 18 m"); break;
    case 0xD6: MyNanode = 1;  Serial.print("n1 "); Serial.print("f37667 - "); Serial.println("Aurora")   ; break;
    case 0xC2: MyNanode = 2;  Serial.print("n2 "); Serial.print("f37668 - "); Serial.println("FemtoGrid"); break;
    case 0xEA: MyNanode = 3;  Serial.print("n3 "); Serial.print("f35020 - "); Serial.println("Skystream"); break;
    case 0xAC: MyNanode = 4;  Serial.print("n4 "); Serial.print("f40385 - "); Serial.println("Grid RMS #1"); break;
    case 0x8E: MyNanode = 5;  Serial.print("n5 "); Serial.print("f40386 - "); Serial.println("Grid RMS #2"); break;
    default:  
      Serial.println("unknown Nanode");
      Serial.print("nx "); Serial.print("f40448 - "); Serial.println("ArduGrid Free Room"); break; 
   }

  // Ethernet/Internet setup
  while (ether.begin(sizeof Ethernet::buffer, macaddr) == 0) { Serial.println( "Failed to access Ethernet controller"); }
  while (!ether.dhcpSetup()) { Serial.println("DHCP failed"); }
  ether.printIp("IP:  ", ether.myip);
  ether.printIp("GW:  ", ether.gwip);  
  ether.printIp("DNS: ", ether.dnsip);  
  while (!ether.dnsLookup(PSTR("api.pachube.com"))) { Serial.println("DNS failed"); }
  ether.printIp("SRV: ", ether.hisip);  // IP for Pachupe API found by DNS service
  
  
  // interrupt 1 on digital pin 3 for PowerMeter pulses
  attachInterrupt(1, PowerMeterPulse, RISING);
  PulseTimeLast = micros();

}
  
// **********************
// -- MAIN LOOP
// **********************
void loop()  // START Pachube section
{  
  int j = 0;
  while ( j < 180 )  // As Pachube feeds may hang at times, reboot regularly. We will monitor stability then remove reboot when OK
  // a value of 180 with an update to Pachube every 10 seconds provoque a reboot every 30 mn. Reboot is very fast.
  {
    ether.packetLoop(ether.packetReceive());  // check response from Pachube
      
  if ( ( millis()-lastupdate ) > REQUEST_RATE )
  {
    lastupdate = millis();
    timer = lastupdate;
    j++;
    
    // DHCP expiration is a bit brutal, because all other ethernet activity and
    // incoming packets will be ignored until a new lease has been acquired
    if ( ether.dhcpExpired() && !ether.dhcpSetup() )
    { 
      Serial.println("DHCP failed");
      delay (200); // delay to let the serial port buffer some time to send the message before rebooting
      software_Reset() ;  // Reboot so can a new lease can be obtained
    }
    
    // Get PowerMeter data 
    // ********************
    PowerMeterLoop();
    if (FirstLoop <= 2) { return; } // Discard first sets of data to make sure you get clean data
    
Serial.print("\nPower: ");
Serial.print(Power);
Serial.print("   watts");
Serial.println("");

    // Prepare string to send 
    // **********************
    
    byte sd = stash.create();  // Initialise send data buffer
    
    if (abs(Power) > 0.10)
      {
        stash.print("0,"); // Datastream 0 - Power in Watts
        stash.println( Power );
      }
     else
      {
        stash.print("0,"); // Datastream 0 - Power in Watts
        stash.println( "0.00");
      } 
    
    stash.print("10,"); // Datastream 10 - Nanode Health
    stash.println( j );
    
    stash.save(); // Close streaming send data buffer
 
    // Select the destination feed according to what the Nanode board is assigned to    
    switch ( MyNanode )
    {
      case 6: // Anemometre/Girouette Etel 6 m 
        Stash::prepare(PSTR("PUT http://$F/v2/feeds/$F.csv HTTP/1.0" "\r\n"
                        "Host: $F" "\r\n"
                        "X-PachubeApiKey: $F" "\r\n"
                        "Content-Length: $D" "\r\n"
                        "\r\n"
                        "$H"),
                        PSTR("api.pachube.com"), PSTR("38277"), PSTR("api.pachube.com"), PSTR(APIKEY), stash.size(), sd);
        break;
    
      case 9:  // Anemometre/Girouette Etel 9 m 
        Stash::prepare(PSTR("PUT http://$F/v2/feeds/$F.csv HTTP/1.0" "\r\n"
                        "Host: $F" "\r\n"
                        "X-PachubeApiKey: $F" "\r\n"
                        "Content-Length: $D" "\r\n"
                        "\r\n"
                        "$H"),
                        PSTR("api.pachube.com"), PSTR("38278"), PSTR("api.pachube.com"), PSTR(APIKEY), stash.size(), sd);
        break;
  
      case 8:   // Anemometre/Girouette Etel 12 m 
        Stash::prepare(PSTR("PUT http://$F/v2/feeds/$F.csv HTTP/1.0" "\r\n"
                        "Host: $F" "\r\n"
                        "X-PachubeApiKey: $F" "\r\n"
                        "Content-Length: $D" "\r\n"
                        "\r\n"
                        "$H"),
                        PSTR("api.pachube.com"), PSTR("38279"), PSTR("api.pachube.com"), PSTR(APIKEY), stash.size(), sd);
        break;
     
      case 7:   // Anemometre/Girouette Etel 18 m 
        Stash::prepare(PSTR("PUT http://$F/v2/feeds/$F.csv HTTP/1.0" "\r\n"
                        "Host: $F" "\r\n"
                        "X-PachubeApiKey: $F" "\r\n"
                        "Content-Length: $D" "\r\n"
                        "\r\n"
                        "$H"),
                        PSTR("api.pachube.com"), PSTR("38281"), PSTR("api.pachube.com"), PSTR(APIKEY), stash.size(), sd);
        break;
       
      case 1: // Aurora
        Stash::prepare(PSTR("PUT http://$F/v2/feeds/$F.csv HTTP/1.0" "\r\n"
                        "Host: $F" "\r\n"
                        "X-PachubeApiKey: $F" "\r\n"
                        "Content-Length: $D" "\r\n"
                        "\r\n"
                        "$H"),
                        PSTR("api.pachube.com"), PSTR("37667"), PSTR("api.pachube.com"), PSTR(APIKEY), stash.size(), sd);
         break;
        
      case 2: // FemtoGrid
        Stash::prepare(PSTR("PUT http://$F/v2/feeds/$F.csv HTTP/1.0" "\r\n"
                        "Host: $F" "\r\n"
                        "X-PachubeApiKey: $F" "\r\n"
                        "Content-Length: $D" "\r\n"
                        "\r\n"
                        "$H"),
                        PSTR("api.pachube.com"), PSTR("37668"), PSTR("api.pachube.com"), PSTR(APIKEY), stash.size(), sd);
        break;
        
      case 3: // Skystream
        Stash::prepare(PSTR("PUT http://$F/v2/feeds/$F.csv HTTP/1.0" "\r\n"
                        "Host: $F" "\r\n"
                        "X-PachubeApiKey: $F" "\r\n"
                        "Content-Length: $D" "\r\n"
                        "\r\n"
                        "$H"),
                        PSTR("api.pachube.com"), PSTR("35020"), PSTR("api.pachube.com"), PSTR(APIKEY), stash.size(), sd);
        break;
        
      case 4: // Grid RMS #1
        Stash::prepare(PSTR("PUT http://$F/v2/feeds/$F.csv HTTP/1.0" "\r\n"
                        "Host: $F" "\r\n"
                        "X-PachubeApiKey: $F" "\r\n"
                        "Content-Length: $D" "\r\n"
                        "\r\n"
                        "$H"),
                        PSTR("api.pachube.com"), PSTR("40385"), PSTR("api.pachube.com"), PSTR(APIKEY), stash.size(), sd);
        break;
        
      case 5: // Grid RMS #2
        Stash::prepare(PSTR("PUT http://$F/v2/feeds/$F.csv HTTP/1.0" "\r\n"
                        "Host: $F" "\r\n"
                        "X-PachubeApiKey: $F" "\r\n"
                        "Content-Length: $D" "\r\n"
                        "\r\n"
                        "$H"),
                        PSTR("api.pachube.com"), PSTR("40386"), PSTR("api.pachube.com"), PSTR(APIKEY), stash.size(), sd);
        break;
        
      default: // ArduGrid Free Room on Pachube -- https://pachube.com/feeds/40448
        Stash::prepare(PSTR("PUT http://$F/v2/feeds/$F.csv HTTP/1.0" "\r\n"
                  "Host: $F" "\r\n"
                  "X-PachubeApiKey: $F" "\r\n"
                  "Content-Length: $D" "\r\n"
                  "\r\n"
                  "$H"),
                  PSTR("api.pachube.com"), PSTR("40448"), PSTR("api.pachube.com"), PSTR(APIKEY), stash.size(), sd);
        break;
    }
    
    // send the packet - this also releases all stash buffers once done
    ether.tcpSend();
    Serial.println("-- sending --"); 

            
    for (int i=0; i < 4; i++) { digitalWrite(6,!digitalRead(6)); delay (50);} // blink LED 6 a bit to show some activity on the board when sending to Pachube
  }
}
  
  // reboot now to clean all dirty buffers to avoid Pachube feed hanging.
  Serial.println("-- rebooting --"); delay (250); 
  software_Reset() ;
 
// END -- Ethernet/Pachube section 
}


// **********************
// -- FUNCTIONS
// **********************

void PowerMeterLoop ()    // START PowerMeter section
{
  // with micros()
  Frequency = (1000000.0*PulsesNbr)/PulsesCumulatedTime;
  Power = Frequency * 5.0;
  Power = Power / 1.105;  // Calibration correction -- Thierry
  if (!bPowerSign){ Power = -Power;}
  
  bPowerSign = digitalRead(4);  // Read Power Sign REVP
  // show power sign on LED 6  (LED ON = Inverter Production)
  if (bPowerSign){ digitalWrite(6, 0);} else {digitalWrite(6, 1);}

  Serial.println("");  
  Serial.println("");  
  Serial.print("Frequency: ");
  Serial.print(Frequency,DEC);
  Serial.print(" Hz -- Power: ");
  Serial.print(Power,DEC);
  Serial.print(" watts -- Sign: ");
  if (bPowerSign) { Serial.println("+ Production"); } else { Serial.println("- Consommation"); }
  Serial.println("");
  
  Serial.print("    ");  
  Serial.print(PulsesNbr,DEC);
  Serial.print(" pulses   ");  
  Serial.print(PulsesCumulatedTime,DEC);
  Serial.print(" microseconds between pachube updates   "); 
  Serial.println("");

  PulsesCumulatedTime = 0;
  PulsesNbr = 0;
  MinPulseTimeInterval = 1000000000;
  
  if (FirstLoop <= 3)
  {
    FirstLoop = FirstLoop + 1;
    Serial.println("> First 2 loops, discard data <");
  }
}


void PowerMeterPulse()
{
   noInterrupts();            // disable global interrupts
   PulseTimeNow = micros();   // Micros() is more precise to compute pulse width that millis();
   PulseTimeInterval = PulseTimeNow - PulseTimeLast;
   PulseTimeLast = PulseTimeNow;
   PulsesCumulatedTime = PulsesCumulatedTime + PulseTimeInterval;
   PulsesNbr++;
   interrupts();              // Re-enable Interrupts
}

 void GetMac()
  {
    Serial.print("Reading MAC address... ");
    bMac=unio.read( macaddr, NANODE_MAC_ADDRESS, 6 );
    if ( bMac ) Serial.println("success");
    else Serial.println("failure");
    
    Serial.print("MAC: ");
    for ( int i=0; i < 6; i++ ) 
    {
      if ( macaddr[i] < 16 ) Serial.print("0");
      Serial.print( macaddr[i], HEX);
      if ( i < 5 ) Serial.print(":"); else Serial.print("");
    }
    Serial.println("");
  }

void software_Reset() // Restarts program from beginning but does not reset the peripherals and registers
  {
     asm volatile ("  jmp 0");  
  } 
  
